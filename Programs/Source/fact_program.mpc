# (C) 2018 University of Bristol. See License.txt
# coding: latin-1
"""
  Solve Bankers bonus, aka Millionaires problem.
  to deduce the maximum value from a range of integer input.

  Demonstrate clients external to computing parties supplying input and receiving an authenticated result. See bankers-bonus-client.cpp for client (and setup instructions).

  For an implementation with communications security see bankers_bonus_commsec.mpc.
  
  Wait for MAX_NUM_CLIENTS to join the game or client finish flag to be sent
  before calculating the maximum.

  Note each client connects in a single thread and so is potentially blocked.
  
  Each round / game will reset and so this runs indefinitiely.
"""

from Compiler.types import sint, regint, Array, MemValue
from Compiler.instructions import listen, acceptclientconnection
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else
from Compiler import floatingpoint

# need sufficient bit length
program.bit_length = 464

PORTNUM = 14000
MAX_NUM_CLIENTS = 2
MAX_INPUT_SIZE = 100

def compute_mean(database, db_size):   
    # need array in order to modify in loop
    sum = Array(1, sfix)

    # hack to init sum[0]
    val = sfix()
    val.load_int(database[0])
    sum[0] = val

    @for_range(db_size)
    def loop_body(i):
        # convert to sfix and update counter
        entry = sfix()
        entry.load_int(database[i])
        
        sum[0] = sum[0] + entry

    size = cfix()
    size.load_int(db_size)
    mean = (sum[0]/size)
    print_ln('[DEBUG]: mean = %s.', mean)
    return mean

def compute_mean_and_variance(database, db_size):
    # need array in order to modify in loop
    sumsq = Array(1, sfix) # ∑ x^2 for x in DB
    sum   = Array(1, sfix) # ∑ x for x in DB

    # hack to init sum[0] as fixed point 
    zerof = sfix()
    zerof.load_int(0)
    sumsq[0] = zerof
    sum[0] = zerof

    @for_range(db_size)
    def loop_body(i):
        # convert to sfix and update counter
        entry = sfix()
        entry.load_int(database[i])
        print_ln('entry %s = %s.', i, entry.reveal())
        
        sum[0] = sum[0] + entry
        sumsq[0] = sumsq[0] + (entry*entry)

        # DEBUG
        # print_ln('sum = %s.', sum[0].reveal())
        # print_ln('sum^2 = %s.', sumsq[0].reveal())

    size = cfix()
    size.load_int(db_size)
    mean = (sum[0]/size)
    variance = (sumsq[0]/size) - (mean*mean)

    return mean, variance

def compute_t_test(database, size_x, size_y):

    # recall: databse = [x1, x2, ... , xn, y1, y2, ... ,yn]
    vector_x = Array(MAX_NUM_CLIENTS*MAX_INPUT_SIZE, sint)
    vector_y = Array(MAX_NUM_CLIENTS*MAX_INPUT_SIZE, sint)
    size_x_fix = cfix()
    size_x_fix.load_int(size_x)

    size_y_fix = cfix()
    size_y_fix.load_int(size_y)

    # copy the "columns" from database to respective vectors
    @for_range(size_x)
    def loop_body(i):
        # print_ln('vector_x[%s] = %s.', i, database[i].reveal())
        vector_x[i] = database[i] 
    
    @for_range(size_y)
    def loop_body(j):
        # print_ln('vector_y[%s] = %s.', j, database[size_x+j].reveal())
        vector_y[j] = database[size_x+j] 

    # get the mean and variance 
    mean_x, var_x = compute_mean_and_variance(vector_x, size_x)
    mean_y, var_y = compute_mean_and_variance(vector_y, size_y)
    print_ln('mean_x = %s.', mean_x.reveal())
    print_ln('mean_y = %s.', mean_y.reveal())
    print_ln('var_x = %s.', var_x.reveal())
    print_ln('var_y = %s.', var_y.reveal())


    # compute t statistic (squared)
    one_fix = cfix(1)
    two_fix = cfix(2)
    numerator = mean_x - mean_y
    
    spooled = (size_x_fix - one_fix) * var_x + (size_y_fix - one_fix) * var_y
    spooled = spooled/(size_x_fix + size_y_fix - two_fix)
    denominator = ((one_fix/size_x_fix) + (one_fix/size_y_fix))*spooled

    t2 = (numerator * numerator)/denominator

    return t2

def compute_pearson_test(database, input_sizes, num_n, num_clients):

    # recall: databse = [x1, x2, ... , xn, y1, y2, ... ,yn]
    vector_x = Array(MAX_NUM_CLIENTS*MAX_INPUT_SIZE, sint)
    vector_y = Array(MAX_NUM_CLIENTS*MAX_INPUT_SIZE, sint)
    db_size_fix = cfix()
    db_size_fix.load_int(num_n)

    # copy the "columns" from database to respective vectors
    skip_idx = MemValue(regint(0))

    @for_range(num_clients)
    def loop_body(i):
        @for_range(input_sizes[i])
        def loop_body(j):
            vector_x[skip_idx + j] = database[j + i*MAX_INPUT_SIZE] 
            vector_y[skip_idx + j] = database[input_sizes[i] + j+ i*MAX_INPUT_SIZE] 
        skip_idx.write(skip_idx + 2*input_sizes[i])

    # get the mean and variance 
    mean_x, var_x = compute_mean_and_variance(vector_x, num_n)
    mean_y, var_y = compute_mean_and_variance(vector_y, num_n)
    
    # debug print
    print_ln('[DEBUG]: mean_x = %s.', mean_x.reveal())
    print_ln('[DEBUG]: mean_y = %s.', mean_y.reveal())
    print_ln('[DEBUG]: var_x = %s.', var_x.reveal())
    print_ln('[DEBUG]: var_y = %s.', var_y.reveal())

    # compute (xi - mean_x)(yi - mean_y)
    sumsq = Array(1, sfix)
    zero_fix = sfix()
    zero_fix.load_int(0)
    sumsq[0] = zero_fix
    
    @for_range(num_n)
    def loop_body(i):
       sumsq[0] = sumsq[0] + (vector_x[i] - mean_x)*(vector_y[i] - mean_y)

    # compute r statistic (squared)
    numerator = sumsq[0]
    print_ln('[DEBUG]: numerator = %s.', numerator.reveal())

    denominator = var_x*var_y
    print_ln('[DEBUG]: denominator = %s.', denominator.reveal())

    r2 = (numerator * numerator)/denominator
    r2 = r2/(db_size_fix * db_size_fix)

    return r2


def accept_client_input():
    """
    Wait for socket connection, send share of random value, receive input and deduce share.
    Expect 2 inputs: unique id, [params, input data...]
    """
    client_socket_id = regint()
    acceptclientconnection(client_socket_id, PORTNUM)
    
    client_inputs = sint.receive_from_client(MAX_INPUT_SIZE, client_socket_id)
    return client_socket_id, client_inputs


def write_result_to_clients(sockets, num_clients, sum):
    """Send share of winning client id to all clients who joined game."""

    # Setup authenticate result using share of random.
    # client can validate ∑ sum * ∑ rnd_from_triple = ∑ auth_result
    rnd_from_triple = sint.get_random_triple()[0]
    auth_result = sum * rnd_from_triple

    @for_range(num_clients)
    def loop_body(i):
        sint.write_shares_to_socket(sockets[i], [sum, rnd_from_triple, auth_result])


def main():
    """Listen in while loop for players to join a game.
    Once maxiumum reached or have notified that round finished, run comparison and return result.
    """
    
    # Start listening for client socket connections
    listen(PORTNUM)
    print_ln('Listening for client connections on base port %s', PORTNUM)

    @do_while
    def game_loop():
        print_ln('Waiting for data upload by client for new statistical test.')

        # clients socket id (integer).
        client_sockets = Array(MAX_NUM_CLIENTS, regint)
      
        # number of clients
        num_clients = MemValue(regint(0))

        ## db size vars
        # total data points per column (2 columns) across all inputs
        num_data_points = MemValue(regint(0)) 

        # size per user entry
        input_sizes = Array(MAX_NUM_CLIENTS, regint) 

        # clients secret input
        client_db = Array(MAX_INPUT_SIZE, sint)

        # merged database of different client uploads
        database = Array(MAX_NUM_CLIENTS*MAX_INPUT_SIZE, sint)

        # loop round waiting for each client to connect
        @do_while
        def client_connections():
            
            # get the next client's database
            client_sockets[num_clients], client_data = accept_client_input()
            
            # check whether the clients have finished uploading their databases
            # TODO: number of features should be a parameter
            client_input_size = client_data[0] # get the database size first feature
            finish = client_data[1] # get the finish flag bit

            print_ln('Received inputs: size = %s, finish = %s.', 
                    client_input_size.reveal(), finish.reveal())

            # update total size of db 
            num_data_points.write(num_data_points + client_input_size.reveal())
            input_sizes[num_clients] = MemValue(client_input_size.reveal())
                        
            num_extra_data = 2 # TODO: make param

            # merge the client database into the main database 
            # recall, first two entries are num_data_points and finish flag so 
            # we start at index 2 TODO: fix to support arbitrary params
            for i in range(MAX_INPUT_SIZE-num_extra_data):
                database[num_clients*MAX_INPUT_SIZE + i] = client_data[i+num_extra_data]
                # print_ln('[DEBUG]: client_data[%s] = %s', i, client_data[i+num_extra_data].reveal())

            # update total number of clients 
            num_clients.write(num_clients+1)

            # continue while both expressions are false
            return (num_clients >= MAX_NUM_CLIENTS) + finish.reveal() == 0 

        # t2 = compute_t_test(database, input_sizes, num_data_points, num_clients)
        r2 = compute_pearson_test(database, input_sizes, num_data_points, num_clients)

        # print_ln('T-test statistic t^2 = %s', t2.reveal())
        print_ln('Pearson statistic r^2 = %s', r2.reveal())

        ret = r2.conv()
        write_result_to_clients(client_sockets, num_clients, ret)

        return True

# start
main()
