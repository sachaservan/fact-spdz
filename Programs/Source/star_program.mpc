# (C) 2018 University of Bristol. See License.txt
# coding: latin-1
"""
  Wait for MAX_NUM_CLIENTS to join the game or client finish flag to be sent
  before calculating the maximum.
  Note each client connects in a single thread and so is potentially blocked.
  Each round / game will reset and so this runs indefinitiely.
"""

from Compiler.types import sint, regint, Array, MemValue, Matrix
from Compiler.instructions import listen, acceptclientconnection
from Compiler.library import print_ln, do_while, for_range
from Compiler import floatingpoint
import math # python math

# need sufficient bit length (dealing with 64 bit ints + 40 bit security so must be > 104 bits)
program.bit_length = 128

# set program security
program.security = 40

PORT_NUM = 14000

# upload limits
MAX_NUM_DATASETS = 6 
MAX_DATASET_SIZE = 100
MAX_SELECTED_ATTR = 20
MAX_EXTRA_INPUTS = 30 

# client actions
ACTION_UPLOAD = regint(0)
ACTION_TTEST = regint(1)
ACTION_PEARSON = regint(2)
ACTION_CHISQ = regint(3)
ACTION_FTEST = regint(4)
ACTION_UNKNOWN = regint(-1)

def compute_mean(database, db_size):   
    # need array in order to modify in loop
    sum = Array(1, sfix)

    # hack to init sum[0]
    val = sfix()
    val.load_int(database[0])
    sum[0] = val

    @for_range(db_size)
    def loop_body(i):
        # convert to sfix and update counter
        entry = sfix()
        entry.load_int(database[i])
        
        sum[0] = sum[0] + entry

    size = cfix()
    size.load_int(db_size)
    mean = (sum[0]/size)
    # print_ln('[DEBUG]: mean = %s.', mean)
    return mean

def compute_mean_and_variance(database, db_size):
    # need array in order to modify in loop
    sumsq = Array(1, sfix) # ∑ x^2 for x in DB
    sum   = Array(1, sfix) # ∑ x for x in DB

    # hack to init sum[0] as fixed point 
    zerof = sfix()
    zerof.load_int(0)
    sumsq[0] = zerof
    sum[0] = zerof

    @for_range(db_size)
    def loop_body(i):
        # convert to sfix and update counter
        entry = sfix()
        entry.load_int(database[i])
        # print_ln('[DEBUG]: entry %s = %s.', i, entry.reveal())
        
        sum[0] = sum[0] + entry
        sumsq[0] = sumsq[0] + (entry*entry)

        # DEBUG
        # print_ln('sum = %s.', sum[0].reveal())
        # print_ln('sum^2 = %s.', sumsq[0].reveal())

    size = cfix()
    size.load_int(db_size)
    mean = (sum[0]/size)
    variance = (sumsq[0]/size) - (mean*mean)

    return mean, variance

def compute_ttest(database, num_rows, attr_x, attr_y):

    # recall: databse = [values..., x1, x2, ... , xn, other values, y1, y2, ... ,yn, more values...]
    # given attr_x and attr_y we must "extract" the correct columns
    vector_x = Array(MAX_DATASET_SIZE, sint)
    vector_y = Array(MAX_DATASET_SIZE, sint)
    num_rows_fix = cfix()
    num_rows_fix.load_int(num_rows)

    # extact the "columns" from database and copy to vectors
    skip_idx_x = MemValue(regint(0))
    skip_idx_x.write(attr_x*num_rows)

    skip_idx_y = MemValue(regint(0))
    skip_idx_y.write(attr_y*num_rows)

    @for_range(num_rows)
    def loop_body(i):
        vector_x[i] = database[skip_idx_x + i] 
        vector_y[i] = database[skip_idx_y + i] 

    # get the mean and variance 
    mean_x, var_x = compute_mean_and_variance(vector_x, num_rows)
    mean_y, var_y = compute_mean_and_variance(vector_y, num_rows)

    # print_ln('[DEBUG]: mean_x = %s.', mean_x.reveal())
    # print_ln('[DEBUG]: mean_y = %s.', mean_y.reveal())
    # print_ln('[DEBUG]: var_x = %s.', var_x.reveal())
    # print_ln('[DEBUG]: var_y = %s.', var_y.reveal())

    # compute t statistic (squared)
    one_fix = cfix(1)
    two_fix = cfix(2)
    numerator = mean_x - mean_y

    # get the sign bit
    s = numerator < 0
    
    spooled = (num_rows_fix - one_fix) * var_x + (num_rows_fix - one_fix) * var_y
    spooled = spooled/(num_rows_fix + num_rows_fix - two_fix)
    denominator = ((one_fix/num_rows_fix) + (one_fix/num_rows_fix))*spooled

    t2 = (numerator * numerator)/denominator

    # set sign of result
    t2 = t2 * sint(-1) * s + t2*(1-s)

    return t2

def compute_pearson_test(database, num_rows, attr_x, attr_y):

    # recall: databse = [values..., x1, x2, ... , xn, other values, y1, y2, ... ,yn, more values...]
    # given attr_x and attr_y we must "extract" the correct columns
    vector_x = Array(MAX_DATASET_SIZE, sint)
    vector_y = Array(MAX_DATASET_SIZE, sint)
    num_rows_fix = cfix()
    num_rows_fix.load_int(num_rows)

    # extact the "columns" from database and copy to vectors
    skip_idx_x = MemValue(regint(0))
    skip_idx_x.write(attr_x*num_rows)

    skip_idx_y = MemValue(regint(0))
    skip_idx_y.write(attr_y*num_rows)

    @for_range(num_rows)
    def loop_body(i):
        vector_x[i] = database[skip_idx_x + i] 
        vector_y[i] = database[skip_idx_y + i] 

    # get the mean and variance 
    mean_x, var_x = compute_mean_and_variance(vector_x, num_rows)
    mean_y, var_y = compute_mean_and_variance(vector_y, num_rows)
    
    # print_ln('[DEBUG]: mean_x = %s.', mean_x.reveal())
    # print_ln('[DEBUG]: mean_y = %s.', mean_y.reveal())
    # print_ln('[DEBUG]: var_x = %s.', var_x.reveal())
    # print_ln('[DEBUG]: var_y = %s.', var_y.reveal())

    # compute (xi - mean_x)(yi - mean_y)
    sumsq = Array(1, sfix)
    zero_fix = sfix()
    zero_fix.load_int(0)
    sumsq[0] = zero_fix
    
    @for_range(num_rows)
    def loop_body(i):
       sumsq[0] = sumsq[0] + (vector_x[i] - mean_x)*(vector_y[i] - mean_y)

    # compute r statistic (squared)
    numerator = sumsq[0]
    # print_ln('[DEBUG]: numerator = %s.', numerator.reveal())

    denominator = var_x*var_y
    # print_ln('[DEBUG]: denominator = %s.', denominator.reveal())

    # get the sign bit 
    s = numerator < 0
    r2 = (numerator * numerator)/denominator
    r2 = r2/(num_rows_fix * num_rows_fix)
    
    # set sign of result
    r2 = r2 * sint(-1) * s + r2*(1-s)
    return r2


def compute_chisq_test(database, num_rows, num_attrs, selected_attrs):

    observed = Array(MAX_SELECTED_ATTR, sfix)
    expected = Array(MAX_SELECTED_ATTR, sfix)

    zero_fix = sfix()
    zero_fix.load_int(0)

    num_attrs_fix = cfix()
    num_attrs_fix.load_int(num_attrs)

    sum_total = Array(1, sfix)

    # iterate over the selected attributes 
    @for_range(num_attrs)
    def loop_body(i):
        # sum along the rows
        @for_range(num_rows)
        def loop_body(j):
            entry = sfix()
            entry.load_int(database[selected_attrs[i]*num_rows + j])
            # print_ln("[DEBUG]: entry = %s", entry.reveal())
            observed[i] = observed[i] + entry
            sum_total[0] = sum_total[0] + entry

    @for_range(num_attrs)
    def loop_body(i):
        expected[i] = sum_total[0]/num_attrs_fix

    x2 = Array(1, sfix)
    x2[0] = zero_fix
        
    @for_range(num_attrs)
    def loop_body(i):
       val = (observed[i] - expected[i])*(observed[i] - expected[i])
       # print_ln("[DEBUG]: value %s = %s", observed[i].reveal(), expected[i].reveal())
       x2[0] = x2[0] + (val/expected[i])    

    return x2[0]


def compute_ftest(database, num_rows, num_attrs, selected_attrs):

    # https://en.wikipedia.org/wiki/F-test

    global_mean = Array(1, sfix)
    num_rows_total = Array(1, cfix)
    num_rows_total[0] = cfix(0)
    
    # mean for each selected attribute
    means = Array(MAX_SELECTED_ATTR, sfix)

    num_rows_fix = cfix()
    num_rows_fix.load_int(num_rows)

    # get the mean and variance of the selected attributes
    @for_range(num_attrs)
    def loop_body(i):
        # sum along the rows
        @for_range(num_rows)
        def loop_body(j):
            entry = sfix()
            entry.load_int(database[selected_attrs[i]*num_rows + j])
            means[i] = means[i] + entry

            # update global mean
            global_mean[0] = global_mean[0] + entry
        
        # TODO: remove assumption that num_rows_fix is the same for
        # all the selected attributes
        means[i] = means[i] / num_rows_fix
        num_rows_total[0] = num_rows_total[0] + num_rows_fix

    global_mean[0] = global_mean[0] / num_rows_total[0]

    
    # compute K - 1
    denom_1 = cfix()
    denom_1.load_int(num_attrs - 1) 

    # compute N - K
    denom_2 = cfix(num_rows_total[0] - num_attrs )

    # compute the "explained" variance
    var_expl = Array(1, sfix)
    var_expl[0] = sfix(0)

    @for_range(num_attrs)
    def loop_body(i):
        var_expl[0] = var_expl[0] + ((num_rows_fix * (means[i] - global_mean[0])*(means[i] - global_mean[0]))/denom_1)

    # compute the "unexplained" variance
    var_unexpl = Array(1, sfix)
    var_unexpl[0] = sfix(0)

    @for_range(num_attrs)
    def loop_body(i):
        @for_range(num_rows)
        def loop_body(j):
            entry = sfix()
            entry.load_int(database[selected_attrs[i]*num_rows + j])
            var_unexpl[0] = var_unexpl[0] + (entry - means[i])*(entry - means[i])/denom_2

    f = var_unexpl[0]/var_expl[0]

    return f

def accept_client_input():
    """
    Wait for socket connection, send share of random value, receive input and deduce share.
    Expected input form: ARRAY[param0,param1,...,paramn, data...]
    """
    client_socket_id = regint()
    acceptclientconnection(client_socket_id, PORT_NUM)
    
    client_inputs = sint.receive_from_client(MAX_DATASET_SIZE+MAX_EXTRA_INPUTS, client_socket_id)
    return client_socket_id, client_inputs


def write_result_to_client(sockets, res):
    """Send share of winning client id to all clients who joined game."""

    # Setup authenticate result using share of random.
    # client can validate ∑ sum * ∑ rnd_from_triple = ∑ auth_result
    rnd_from_triple = sint.get_random_triple()[0]
    auth_result = res * rnd_from_triple

    sint.write_shares_to_socket(sockets[0], [res, rnd_from_triple, auth_result])


def main():
    """Listen in while loop for players to join a game.
    Once maxiumum reached or have notified that round finished, run comparison and return result.
    """
    
    # Start listening for client socket connections
    listen(PORT_NUM)
    print_ln('Listening for client connections on base port %s', PORT_NUM)

    # db index for uploading (increments after every upload)
    next_db_upload_indx = MemValue(regint(0))

    # db size stuff
    num_rows = Array(MAX_NUM_DATASETS, regint)
    num_cols = Array(MAX_NUM_DATASETS, regint)

    # databases consisting of uploaded datasets (excluding metadata)
    databases = sint.Matrix(MAX_NUM_DATASETS, MAX_DATASET_SIZE)

    @do_while
    def main_loop():
        print_ln('Waiting action from client...')

        # clients socket id (integer).
        client_socket = Array(1, regint)

        # wait for client to connect
        # get the next client's upload
        client_socket[0], client_data = accept_client_input()
        
        # get the requested action e.g., data upload or statistical test
        client_action = client_data[0].reveal()

        # get the dataset id (if computing test)
        # used for selecting the correct dataset to compute the test over
        db_indx = client_data[1].reveal()

        # get size of data upload (if any)
        client_num_rows = client_data[2].reveal()
        client_num_cols = client_data[3].reveal()

        # get the finish flag bit
        finish = client_data[4].reveal()

        # get the number of selected attributes
        num_attr = client_data[5].reveal()

        # selected attributes (2 for ttest and pearson, up to 20 for chisq)
        attrs = Array(MAX_SELECTED_ATTR, regint)

        for i in range(MAX_SELECTED_ATTR):
            # TODO: make this less hacky!
            attrs[i] = client_data[6 + i].reveal() 

        # print_ln("[DEBUG]: selected attributes are %s and %s", attrs[0], attrs[1])

        #####################################
        # (IF) CLIENT WANTS TO UPLOAD DATA
        #####################################
        if_then(client_action == ACTION_UPLOAD)
        print_ln("Client uploading dataset.")

        # update total size of db 
        # note: if action != upload, then this just adds 0 to the current db size
        num_rows[next_db_upload_indx] = client_num_rows
        num_cols[next_db_upload_indx] = client_num_cols
                    
        # copy client's upload data into the database array
        for i in range(MAX_DATASET_SIZE):
            databases[next_db_upload_indx][i] = client_data[i+MAX_EXTRA_INPUTS]
            # print_ln('[DEBUG]: client_data[%s] = %s', i, client_data[i+MAX_EXTRA_INPUTS].reveal())
            
        # increment next upload index
        next_db_upload_indx.write(next_db_upload_indx + 1)

        err = sint(0) # no error
        write_result_to_client(client_socket, err)
        end_if()

        #####################################
        # (IF) CLIENT WANTS TO COMPUTE A T-TEST
        #####################################
        if_then(client_action == ACTION_TTEST)
        print_ln("Client computing t-test.")

        t2 = compute_ttest(databases[db_indx], num_rows[db_indx], attrs[0], attrs[1])
        print_ln('T-test statistic t^2 = %s', t2.reveal())
        err = sint(0) # no error
        write_result_to_client(client_socket, err)
        end_if()

        #####################################
        # (IF) CLIENT WANTS TO COMPUTE A PEARSON TEST
        #####################################
        if_then(client_action == ACTION_PEARSON)
        print_ln("Client computing pearson correlation.")

        r2 = compute_pearson_test(databases[db_indx], num_rows[db_indx], attrs[0], attrs[1])
        print_ln('Pearson statistic r^2 = %s', r2.reveal())
        err = sint(0) # no error
        write_result_to_client(client_socket, err)
        end_if()

        #####################################
        # (IF) CLIENT WANTS TO COMPUTE A CHI-SQ TEST
        #####################################
        if_then(client_action == ACTION_CHISQ)
        print_ln("Client computing chi-sq correlation.")

        x2 = compute_chisq_test(databases[db_indx], num_rows[db_indx], num_attr, attrs)
        print_ln('Chi-squared statistic x^2 = %s', x2.reveal())
        err = sint(0) # no error
        write_result_to_client(client_socket, err)
        end_if()

        #####################################
        # (IF) CLIENT WANTS TO COMPUTE A F-TEST
        #####################################
        if_then(client_action == ACTION_FTEST)
        print_ln("Client computing chi-sq correlation.")

        f = compute_ftest(databases[db_indx], num_rows[db_indx], num_attr, attrs)
        print_ln('F-statistic f = %s', f.reveal())
        err = sint(0) # no error
        write_result_to_client(client_socket, err)
        end_if()

        return finish == 0

# start
main()
